/*
 * generated by Xtext 2.11.0
 */
package cs.queensu.ca.serializer;

import com.google.inject.Inject;
import cs.queensu.ca.services.UnityGrammarAccess;
import cs.queensu.ca.unity.Addition;
import cs.queensu.ca.unity.AndExpression;
import cs.queensu.ca.unity.AreaName;
import cs.queensu.ca.unity.Assign;
import cs.queensu.ca.unity.Attribute;
import cs.queensu.ca.unity.BoolLiteral;
import cs.queensu.ca.unity.Channel;
import cs.queensu.ca.unity.Config;
import cs.queensu.ca.unity.ConfigAssignment;
import cs.queensu.ca.unity.Divide;
import cs.queensu.ca.unity.DotExpression;
import cs.queensu.ca.unity.ENV;
import cs.queensu.ca.unity.EQ;
import cs.queensu.ca.unity.GE;
import cs.queensu.ca.unity.GT;
import cs.queensu.ca.unity.IP;
import cs.queensu.ca.unity.Identifier;
import cs.queensu.ca.unity.Init;
import cs.queensu.ca.unity.Instance;
import cs.queensu.ca.unity.IntLiteral;
import cs.queensu.ca.unity.LE;
import cs.queensu.ca.unity.LT;
import cs.queensu.ca.unity.Map;
import cs.queensu.ca.unity.Message;
import cs.queensu.ca.unity.MetaObject;
import cs.queensu.ca.unity.Minus;
import cs.queensu.ca.unity.Modulo;
import cs.queensu.ca.unity.Multiplication;
import cs.queensu.ca.unity.NE;
import cs.queensu.ca.unity.NotBooleanExpression;
import cs.queensu.ca.unity.OrExpression;
import cs.queensu.ca.unity.OverrideAction;
import cs.queensu.ca.unity.Param;
import cs.queensu.ca.unity.Payload;
import cs.queensu.ca.unity.Port;
import cs.queensu.ca.unity.QName;
import cs.queensu.ca.unity.Range;
import cs.queensu.ca.unity.RealLiteral;
import cs.queensu.ca.unity.SingleRef;
import cs.queensu.ca.unity.Specification;
import cs.queensu.ca.unity.StLiteral;
import cs.queensu.ca.unity.UnaryExpression;
import cs.queensu.ca.unity.UnityObject;
import cs.queensu.ca.unity.UnityPackage;
import cs.queensu.ca.unity.Value;
import cs.queensu.ca.unity.VarType;
import cs.queensu.ca.unity.interfaceType;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class UnitySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UnityGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UnityPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UnityPackage.ACTION:
				sequence_Action(context, (cs.queensu.ca.unity.Action) semanticObject); 
				return; 
			case UnityPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case UnityPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case UnityPackage.AREA_NAME:
				sequence_AreaName(context, (AreaName) semanticObject); 
				return; 
			case UnityPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case UnityPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case UnityPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case UnityPackage.CHANNEL:
				sequence_Channel(context, (Channel) semanticObject); 
				return; 
			case UnityPackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case UnityPackage.CONFIG_ASSIGNMENT:
				sequence_ConfigAssignment(context, (ConfigAssignment) semanticObject); 
				return; 
			case UnityPackage.DIVIDE:
				sequence_Multiplication(context, (Divide) semanticObject); 
				return; 
			case UnityPackage.DOT_EXPRESSION:
				sequence_DotExpression(context, (DotExpression) semanticObject); 
				return; 
			case UnityPackage.ENV:
				sequence_ENV(context, (ENV) semanticObject); 
				return; 
			case UnityPackage.EQ:
				sequence_ComparisonOperators(context, (EQ) semanticObject); 
				return; 
			case UnityPackage.GE:
				sequence_ComparisonOperators(context, (GE) semanticObject); 
				return; 
			case UnityPackage.GT:
				sequence_ComparisonOperators(context, (GT) semanticObject); 
				return; 
			case UnityPackage.IP:
				sequence_IP(context, (IP) semanticObject); 
				return; 
			case UnityPackage.IDENTIFIER:
				sequence_Identifier(context, (Identifier) semanticObject); 
				return; 
			case UnityPackage.INIT:
				sequence_Init(context, (Init) semanticObject); 
				return; 
			case UnityPackage.INSTANCE:
				sequence_Instance(context, (Instance) semanticObject); 
				return; 
			case UnityPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case UnityPackage.LE:
				sequence_ComparisonOperators(context, (LE) semanticObject); 
				return; 
			case UnityPackage.LT:
				sequence_ComparisonOperators(context, (LT) semanticObject); 
				return; 
			case UnityPackage.MAP:
				sequence_Map(context, (Map) semanticObject); 
				return; 
			case UnityPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case UnityPackage.META_OBJECT:
				sequence_MetaObject(context, (MetaObject) semanticObject); 
				return; 
			case UnityPackage.MINUS:
				sequence_Addition(context, (Minus) semanticObject); 
				return; 
			case UnityPackage.MODULO:
				sequence_Multiplication(context, (Modulo) semanticObject); 
				return; 
			case UnityPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case UnityPackage.NE:
				sequence_ComparisonOperators(context, (NE) semanticObject); 
				return; 
			case UnityPackage.NOT_BOOLEAN_EXPRESSION:
				sequence_NotBooleanExpression(context, (NotBooleanExpression) semanticObject); 
				return; 
			case UnityPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case UnityPackage.OVERRIDE_ACTION:
				sequence_OverrideAction(context, (OverrideAction) semanticObject); 
				return; 
			case UnityPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case UnityPackage.PAYLOAD:
				sequence_Payload(context, (Payload) semanticObject); 
				return; 
			case UnityPackage.PORT:
				sequence_Port(context, (Port) semanticObject); 
				return; 
			case UnityPackage.QNAME:
				sequence_QName(context, (QName) semanticObject); 
				return; 
			case UnityPackage.RANGE:
				sequence_Range(context, (Range) semanticObject); 
				return; 
			case UnityPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case UnityPackage.SINGLE_REF:
				sequence_SingleRef(context, (SingleRef) semanticObject); 
				return; 
			case UnityPackage.SPECIFICATION:
				sequence_Specification(context, (Specification) semanticObject); 
				return; 
			case UnityPackage.ST_LITERAL:
				sequence_StLiteral(context, (StLiteral) semanticObject); 
				return; 
			case UnityPackage.UNARY_EXPRESSION:
				sequence_Unary(context, (UnaryExpression) semanticObject); 
				return; 
			case UnityPackage.UNITY_OBJECT:
				sequence_UnityObject(context, (UnityObject) semanticObject); 
				return; 
			case UnityPackage.VALUE:
				sequence_Value(context, (Value) semanticObject); 
				return; 
			case UnityPackage.VAR_TYPE:
				sequence_VarType(context, (VarType) semanticObject); 
				return; 
			case UnityPackage.INTERFACE_TYPE:
				sequence_interfaceType(context, (interfaceType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=ID payload=Payload? returnPayload=Payload? expressions+=Expression*)
	 */
	protected void sequence_Action(ISerializationContext context, cs.queensu.ca.unity.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Addition
	 *     Assign returns Addition
	 *     Assign.Assign_1_0 returns Addition
	 *     OrExpression returns Addition
	 *     OrExpression.OrExpression_1_0 returns Addition
	 *     AndExpression returns Addition
	 *     AndExpression.AndExpression_1_0 returns Addition
	 *     ComparisonOperators returns Addition
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Addition
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Addition
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Addition
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Addition
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Addition
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0_0_0_0 returns Addition
	 *     Addition.Minus_1_0_0_1_0 returns Addition
	 *     Multiplication returns Addition
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Addition
	 *     Multiplication.Divide_1_0_0_1_0 returns Addition
	 *     Multiplication.Modulo_1_0_0_2_0 returns Addition
	 *     Unary returns Addition
	 *     UnaryExpressionNotPlusMinus returns Addition
	 *     PrimaryExpression returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0_0_0_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getAdditionLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Minus
	 *     Assign returns Minus
	 *     Assign.Assign_1_0 returns Minus
	 *     OrExpression returns Minus
	 *     OrExpression.OrExpression_1_0 returns Minus
	 *     AndExpression returns Minus
	 *     AndExpression.AndExpression_1_0 returns Minus
	 *     ComparisonOperators returns Minus
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Minus
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Minus
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Minus
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Minus
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Minus
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Minus
	 *     Addition returns Minus
	 *     Addition.Addition_1_0_0_0_0 returns Minus
	 *     Addition.Minus_1_0_0_1_0 returns Minus
	 *     Multiplication returns Minus
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Minus
	 *     Multiplication.Divide_1_0_0_1_0 returns Minus
	 *     Multiplication.Modulo_1_0_0_2_0 returns Minus
	 *     Unary returns Minus
	 *     UnaryExpressionNotPlusMinus returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=Addition_Minus_1_0_0_1_0 right=Multiplication)
	 */
	protected void sequence_Addition(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionAccess().getMinusLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionAccess().getRightMultiplicationParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     Assign returns AndExpression
	 *     Assign.Assign_1_0 returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     ComparisonOperators returns AndExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns AndExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns AndExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns AndExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns AndExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns AndExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns AndExpression
	 *     Addition returns AndExpression
	 *     Addition.Addition_1_0_0_0_0 returns AndExpression
	 *     Addition.Minus_1_0_0_1_0 returns AndExpression
	 *     Multiplication returns AndExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns AndExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns AndExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns AndExpression
	 *     Unary returns AndExpression
	 *     UnaryExpressionNotPlusMinus returns AndExpression
	 *     PrimaryExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 right=ComparisonOperators)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightComparisonOperatorsParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AreaName returns AreaName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_AreaName(ISerializationContext context, AreaName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.AREA_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.AREA_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAreaNameAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assign
	 *     Assign returns Assign
	 *     Assign.Assign_1_0 returns Assign
	 *     OrExpression returns Assign
	 *     OrExpression.OrExpression_1_0 returns Assign
	 *     AndExpression returns Assign
	 *     AndExpression.AndExpression_1_0 returns Assign
	 *     ComparisonOperators returns Assign
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Assign
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Assign
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Assign
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Assign
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Assign
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Assign
	 *     Addition returns Assign
	 *     Addition.Addition_1_0_0_0_0 returns Assign
	 *     Addition.Minus_1_0_0_1_0 returns Assign
	 *     Multiplication returns Assign
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Assign
	 *     Multiplication.Divide_1_0_0_1_0 returns Assign
	 *     Multiplication.Modulo_1_0_0_2_0 returns Assign
	 *     Unary returns Assign
	 *     UnaryExpressionNotPlusMinus returns Assign
	 *     PrimaryExpression returns Assign
	 *
	 * Constraint:
	 *     (left=Assign_Assign_1_0 right=OrExpression)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.ASSIGN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.ASSIGN__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.ASSIGN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.ASSIGN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAccess().getAssignLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignAccess().getRightOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Attribute
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     (name=ID propertyType=VarType range=Range?)
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoolLiteral
	 *     Assign returns BoolLiteral
	 *     Assign.Assign_1_0 returns BoolLiteral
	 *     OrExpression returns BoolLiteral
	 *     OrExpression.OrExpression_1_0 returns BoolLiteral
	 *     AndExpression returns BoolLiteral
	 *     AndExpression.AndExpression_1_0 returns BoolLiteral
	 *     ComparisonOperators returns BoolLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns BoolLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns BoolLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns BoolLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns BoolLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns BoolLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns BoolLiteral
	 *     Addition returns BoolLiteral
	 *     Addition.Addition_1_0_0_0_0 returns BoolLiteral
	 *     Addition.Minus_1_0_0_1_0 returns BoolLiteral
	 *     Multiplication returns BoolLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns BoolLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns BoolLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns BoolLiteral
	 *     Unary returns BoolLiteral
	 *     UnaryExpressionNotPlusMinus returns BoolLiteral
	 *     PrimaryExpression returns BoolLiteral
	 *     LiteralOrIdentifier returns BoolLiteral
	 *     Literal returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     bool=BOOLEAN
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.BOOL_LITERAL__BOOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.BOOL_LITERAL__BOOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoolLiteralAccess().getBoolBOOLEANTerminalRuleCall_1_0(), semanticObject.isBool());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Channel returns Channel
	 *
	 * Constraint:
	 *     (name=ID direction=Direction? type=interfaceType? (port=Port | (areaname=AreaName qname=QName)) boundInstances+=[Instance|ID]*)
	 */
	protected void sequence_Channel(ISerializationContext context, Channel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EQ
	 *     Assign returns EQ
	 *     Assign.Assign_1_0 returns EQ
	 *     OrExpression returns EQ
	 *     OrExpression.OrExpression_1_0 returns EQ
	 *     AndExpression returns EQ
	 *     AndExpression.AndExpression_1_0 returns EQ
	 *     ComparisonOperators returns EQ
	 *     ComparisonOperators.GT_1_0_0_0_0 returns EQ
	 *     ComparisonOperators.LT_1_0_0_1_0 returns EQ
	 *     ComparisonOperators.GE_1_0_0_2_0 returns EQ
	 *     ComparisonOperators.LE_1_0_0_3_0 returns EQ
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns EQ
	 *     ComparisonOperators.NE_1_0_0_5_0 returns EQ
	 *     Addition returns EQ
	 *     Addition.Addition_1_0_0_0_0 returns EQ
	 *     Addition.Minus_1_0_0_1_0 returns EQ
	 *     Multiplication returns EQ
	 *     Multiplication.Multiplication_1_0_0_0_0 returns EQ
	 *     Multiplication.Divide_1_0_0_1_0 returns EQ
	 *     Multiplication.Modulo_1_0_0_2_0 returns EQ
	 *     Unary returns EQ
	 *     UnaryExpressionNotPlusMinus returns EQ
	 *     PrimaryExpression returns EQ
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_EQ_1_0_0_4_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, EQ semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.EQ__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.EQ__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getEQLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GE
	 *     Assign returns GE
	 *     Assign.Assign_1_0 returns GE
	 *     OrExpression returns GE
	 *     OrExpression.OrExpression_1_0 returns GE
	 *     AndExpression returns GE
	 *     AndExpression.AndExpression_1_0 returns GE
	 *     ComparisonOperators returns GE
	 *     ComparisonOperators.GT_1_0_0_0_0 returns GE
	 *     ComparisonOperators.LT_1_0_0_1_0 returns GE
	 *     ComparisonOperators.GE_1_0_0_2_0 returns GE
	 *     ComparisonOperators.LE_1_0_0_3_0 returns GE
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns GE
	 *     ComparisonOperators.NE_1_0_0_5_0 returns GE
	 *     Addition returns GE
	 *     Addition.Addition_1_0_0_0_0 returns GE
	 *     Addition.Minus_1_0_0_1_0 returns GE
	 *     Multiplication returns GE
	 *     Multiplication.Multiplication_1_0_0_0_0 returns GE
	 *     Multiplication.Divide_1_0_0_1_0 returns GE
	 *     Multiplication.Modulo_1_0_0_2_0 returns GE
	 *     Unary returns GE
	 *     UnaryExpressionNotPlusMinus returns GE
	 *     PrimaryExpression returns GE
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_GE_1_0_0_2_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, GE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.GE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.GE__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.GE__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.GE__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getGELeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GT
	 *     Assign returns GT
	 *     Assign.Assign_1_0 returns GT
	 *     OrExpression returns GT
	 *     OrExpression.OrExpression_1_0 returns GT
	 *     AndExpression returns GT
	 *     AndExpression.AndExpression_1_0 returns GT
	 *     ComparisonOperators returns GT
	 *     ComparisonOperators.GT_1_0_0_0_0 returns GT
	 *     ComparisonOperators.LT_1_0_0_1_0 returns GT
	 *     ComparisonOperators.GE_1_0_0_2_0 returns GT
	 *     ComparisonOperators.LE_1_0_0_3_0 returns GT
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns GT
	 *     ComparisonOperators.NE_1_0_0_5_0 returns GT
	 *     Addition returns GT
	 *     Addition.Addition_1_0_0_0_0 returns GT
	 *     Addition.Minus_1_0_0_1_0 returns GT
	 *     Multiplication returns GT
	 *     Multiplication.Multiplication_1_0_0_0_0 returns GT
	 *     Multiplication.Divide_1_0_0_1_0 returns GT
	 *     Multiplication.Modulo_1_0_0_2_0 returns GT
	 *     Unary returns GT
	 *     UnaryExpressionNotPlusMinus returns GT
	 *     PrimaryExpression returns GT
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_GT_1_0_0_0_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, GT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.GT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.GT__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.GT__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.GT__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getGTLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LE
	 *     Assign returns LE
	 *     Assign.Assign_1_0 returns LE
	 *     OrExpression returns LE
	 *     OrExpression.OrExpression_1_0 returns LE
	 *     AndExpression returns LE
	 *     AndExpression.AndExpression_1_0 returns LE
	 *     ComparisonOperators returns LE
	 *     ComparisonOperators.GT_1_0_0_0_0 returns LE
	 *     ComparisonOperators.LT_1_0_0_1_0 returns LE
	 *     ComparisonOperators.GE_1_0_0_2_0 returns LE
	 *     ComparisonOperators.LE_1_0_0_3_0 returns LE
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns LE
	 *     ComparisonOperators.NE_1_0_0_5_0 returns LE
	 *     Addition returns LE
	 *     Addition.Addition_1_0_0_0_0 returns LE
	 *     Addition.Minus_1_0_0_1_0 returns LE
	 *     Multiplication returns LE
	 *     Multiplication.Multiplication_1_0_0_0_0 returns LE
	 *     Multiplication.Divide_1_0_0_1_0 returns LE
	 *     Multiplication.Modulo_1_0_0_2_0 returns LE
	 *     Unary returns LE
	 *     UnaryExpressionNotPlusMinus returns LE
	 *     PrimaryExpression returns LE
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_LE_1_0_0_3_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, LE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.LE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.LE__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.LE__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.LE__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getLELeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LT
	 *     Assign returns LT
	 *     Assign.Assign_1_0 returns LT
	 *     OrExpression returns LT
	 *     OrExpression.OrExpression_1_0 returns LT
	 *     AndExpression returns LT
	 *     AndExpression.AndExpression_1_0 returns LT
	 *     ComparisonOperators returns LT
	 *     ComparisonOperators.GT_1_0_0_0_0 returns LT
	 *     ComparisonOperators.LT_1_0_0_1_0 returns LT
	 *     ComparisonOperators.GE_1_0_0_2_0 returns LT
	 *     ComparisonOperators.LE_1_0_0_3_0 returns LT
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns LT
	 *     ComparisonOperators.NE_1_0_0_5_0 returns LT
	 *     Addition returns LT
	 *     Addition.Addition_1_0_0_0_0 returns LT
	 *     Addition.Minus_1_0_0_1_0 returns LT
	 *     Multiplication returns LT
	 *     Multiplication.Multiplication_1_0_0_0_0 returns LT
	 *     Multiplication.Divide_1_0_0_1_0 returns LT
	 *     Multiplication.Modulo_1_0_0_2_0 returns LT
	 *     Unary returns LT
	 *     UnaryExpressionNotPlusMinus returns LT
	 *     PrimaryExpression returns LT
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_LT_1_0_0_1_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, LT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.LT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.LT__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.LT__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.LT__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getLTLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NE
	 *     Assign returns NE
	 *     Assign.Assign_1_0 returns NE
	 *     OrExpression returns NE
	 *     OrExpression.OrExpression_1_0 returns NE
	 *     AndExpression returns NE
	 *     AndExpression.AndExpression_1_0 returns NE
	 *     ComparisonOperators returns NE
	 *     ComparisonOperators.GT_1_0_0_0_0 returns NE
	 *     ComparisonOperators.LT_1_0_0_1_0 returns NE
	 *     ComparisonOperators.GE_1_0_0_2_0 returns NE
	 *     ComparisonOperators.LE_1_0_0_3_0 returns NE
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns NE
	 *     ComparisonOperators.NE_1_0_0_5_0 returns NE
	 *     Addition returns NE
	 *     Addition.Addition_1_0_0_0_0 returns NE
	 *     Addition.Minus_1_0_0_1_0 returns NE
	 *     Multiplication returns NE
	 *     Multiplication.Multiplication_1_0_0_0_0 returns NE
	 *     Multiplication.Divide_1_0_0_1_0 returns NE
	 *     Multiplication.Modulo_1_0_0_2_0 returns NE
	 *     Unary returns NE
	 *     UnaryExpressionNotPlusMinus returns NE
	 *     PrimaryExpression returns NE
	 *
	 * Constraint:
	 *     (left=ComparisonOperators_NE_1_0_0_5_0 rest=Addition)
	 */
	protected void sequence_ComparisonOperators(ISerializationContext context, NE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.NE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.NE__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.NE__REST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.NE__REST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getNELeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonOperatorsAccess().getRestAdditionParserRuleCall_1_1_0(), semanticObject.getRest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConfigAssignment returns ConfigAssignment
	 *
	 * Constraint:
	 *     configs+=Config+
	 */
	protected void sequence_ConfigAssignment(ISerializationContext context, ConfigAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (propertyName=[Attribute|ID] propertyValue=Expression)
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.CONFIG__PROPERTY_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.CONFIG__PROPERTY_NAME));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.CONFIG__PROPERTY_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.CONFIG__PROPERTY_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConfigAccess().getPropertyNameAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(UnityPackage.Literals.CONFIG__PROPERTY_NAME, false));
		feeder.accept(grammarAccess.getConfigAccess().getPropertyValueExpressionParserRuleCall_2_0(), semanticObject.getPropertyValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DotExpression returns DotExpression
	 *     DotExpression.DotExpression_1_0 returns DotExpression
	 *
	 * Constraint:
	 *     (head=DotExpression_DotExpression_1_0 tail=[Property|ID])
	 */
	protected void sequence_DotExpression(ISerializationContext context, DotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.DOT_EXPRESSION__HEAD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.DOT_EXPRESSION__HEAD));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.DOT_EXPRESSION__TAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.DOT_EXPRESSION__TAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDotExpressionAccess().getDotExpressionHeadAction_1_0(), semanticObject.getHead());
		feeder.accept(grammarAccess.getDotExpressionAccess().getTailPropertyIDTerminalRuleCall_1_2_0_1(), semanticObject.eGet(UnityPackage.Literals.DOT_EXPRESSION__TAIL, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ENV returns ENV
	 *
	 * Constraint:
	 *     (name=ID (channels+=Channel | maps+=Map | instances+=Instance | properties+=Property)* initCodes=Init?)
	 */
	protected void sequence_ENV(ISerializationContext context, ENV semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IP returns IP
	 *
	 * Constraint:
	 *     ipAddr=STRING
	 */
	protected void sequence_IP(ISerializationContext context, IP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.IP__IP_ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.IP__IP_ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIPAccess().getIpAddrSTRINGTerminalRuleCall_2_0(), semanticObject.getIpAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Identifier
	 *     Assign returns Identifier
	 *     Assign.Assign_1_0 returns Identifier
	 *     OrExpression returns Identifier
	 *     OrExpression.OrExpression_1_0 returns Identifier
	 *     AndExpression returns Identifier
	 *     AndExpression.AndExpression_1_0 returns Identifier
	 *     ComparisonOperators returns Identifier
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Identifier
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Identifier
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Identifier
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Identifier
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Identifier
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Identifier
	 *     Addition returns Identifier
	 *     Addition.Addition_1_0_0_0_0 returns Identifier
	 *     Addition.Minus_1_0_0_1_0 returns Identifier
	 *     Multiplication returns Identifier
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Identifier
	 *     Multiplication.Divide_1_0_0_1_0 returns Identifier
	 *     Multiplication.Modulo_1_0_0_2_0 returns Identifier
	 *     Unary returns Identifier
	 *     UnaryExpressionNotPlusMinus returns Identifier
	 *     PrimaryExpression returns Identifier
	 *     LiteralOrIdentifier returns Identifier
	 *     Identifier returns Identifier
	 *
	 * Constraint:
	 *     Refrence=DotExpression
	 */
	protected void sequence_Identifier(ISerializationContext context, Identifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.IDENTIFIER__REFRENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.IDENTIFIER__REFRENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentifierAccess().getRefrenceDotExpressionParserRuleCall_0(), semanticObject.getRefrence());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Init returns Init
	 *
	 * Constraint:
	 *     expressions+=Expression+
	 */
	protected void sequence_Init(ISerializationContext context, Init semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns Instance
	 *
	 * Constraint:
	 *     (name=ID instanceType=[UnityObject|ID])
	 */
	protected void sequence_Instance(ISerializationContext context, Instance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.INSTANCE__NAME));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.INSTANCE__INSTANCE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.INSTANCE__INSTANCE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getInstanceAccess().getInstanceTypeUnityObjectIDTerminalRuleCall_3_0_1(), semanticObject.eGet(UnityPackage.Literals.INSTANCE__INSTANCE_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntLiteral
	 *     Assign returns IntLiteral
	 *     Assign.Assign_1_0 returns IntLiteral
	 *     OrExpression returns IntLiteral
	 *     OrExpression.OrExpression_1_0 returns IntLiteral
	 *     AndExpression returns IntLiteral
	 *     AndExpression.AndExpression_1_0 returns IntLiteral
	 *     ComparisonOperators returns IntLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns IntLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns IntLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns IntLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns IntLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns IntLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns IntLiteral
	 *     Addition returns IntLiteral
	 *     Addition.Addition_1_0_0_0_0 returns IntLiteral
	 *     Addition.Minus_1_0_0_1_0 returns IntLiteral
	 *     Multiplication returns IntLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns IntLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns IntLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns IntLiteral
	 *     Unary returns IntLiteral
	 *     UnaryExpressionNotPlusMinus returns IntLiteral
	 *     PrimaryExpression returns IntLiteral
	 *     LiteralOrIdentifier returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     int=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.INT_LITERAL__INT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.INT_LITERAL__INT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getIntINTTerminalRuleCall_1_0(), semanticObject.getInt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Map returns Map
	 *
	 * Constraint:
	 *     (mapName=ID pathName=StLiteral)
	 */
	protected void sequence_Map(ISerializationContext context, Map semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MAP__MAP_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MAP__MAP_NAME));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MAP__PATH_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MAP__PATH_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMapAccess().getMapNameIDTerminalRuleCall_2_0(), semanticObject.getMapName());
		feeder.accept(grammarAccess.getMapAccess().getPathNameStLiteralParserRuleCall_4_0(), semanticObject.getPathName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (name=ID content=STRING)
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MESSAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MESSAGE__CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MESSAGE__CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMessageAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getMessageAccess().getContentSTRINGTerminalRuleCall_5_0(), semanticObject.getContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MetaObject returns MetaObject
	 *
	 * Constraint:
	 *     (name=ID (kind='car' | kind='rover' | kind='generic' | kind='others') properties+=Attribute? (actions+=Action? properties+=Attribute?)*)
	 */
	protected void sequence_MetaObject(ISerializationContext context, MetaObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Divide
	 *     Assign returns Divide
	 *     Assign.Assign_1_0 returns Divide
	 *     OrExpression returns Divide
	 *     OrExpression.OrExpression_1_0 returns Divide
	 *     AndExpression returns Divide
	 *     AndExpression.AndExpression_1_0 returns Divide
	 *     ComparisonOperators returns Divide
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Divide
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Divide
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Divide
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Divide
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Divide
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Divide
	 *     Addition returns Divide
	 *     Addition.Addition_1_0_0_0_0 returns Divide
	 *     Addition.Minus_1_0_0_1_0 returns Divide
	 *     Multiplication returns Divide
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Divide
	 *     Multiplication.Divide_1_0_0_1_0 returns Divide
	 *     Multiplication.Modulo_1_0_0_2_0 returns Divide
	 *     Unary returns Divide
	 *     UnaryExpressionNotPlusMinus returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=Multiplication_Divide_1_0_0_1_0 right=Unary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.DIVIDE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.DIVIDE__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.DIVIDE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.DIVIDE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getDivideLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightUnaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Modulo
	 *     Assign returns Modulo
	 *     Assign.Assign_1_0 returns Modulo
	 *     OrExpression returns Modulo
	 *     OrExpression.OrExpression_1_0 returns Modulo
	 *     AndExpression returns Modulo
	 *     AndExpression.AndExpression_1_0 returns Modulo
	 *     ComparisonOperators returns Modulo
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Modulo
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Modulo
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Modulo
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Modulo
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Modulo
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Modulo
	 *     Addition returns Modulo
	 *     Addition.Addition_1_0_0_0_0 returns Modulo
	 *     Addition.Minus_1_0_0_1_0 returns Modulo
	 *     Multiplication returns Modulo
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Modulo
	 *     Multiplication.Divide_1_0_0_1_0 returns Modulo
	 *     Multiplication.Modulo_1_0_0_2_0 returns Modulo
	 *     Unary returns Modulo
	 *     UnaryExpressionNotPlusMinus returns Modulo
	 *     PrimaryExpression returns Modulo
	 *
	 * Constraint:
	 *     (left=Multiplication_Modulo_1_0_0_2_0 right=Unary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Modulo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MODULO__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MODULO__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MODULO__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MODULO__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getModuloLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightUnaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Multiplication
	 *     Assign returns Multiplication
	 *     Assign.Assign_1_0 returns Multiplication
	 *     OrExpression returns Multiplication
	 *     OrExpression.OrExpression_1_0 returns Multiplication
	 *     AndExpression returns Multiplication
	 *     AndExpression.AndExpression_1_0 returns Multiplication
	 *     ComparisonOperators returns Multiplication
	 *     ComparisonOperators.GT_1_0_0_0_0 returns Multiplication
	 *     ComparisonOperators.LT_1_0_0_1_0 returns Multiplication
	 *     ComparisonOperators.GE_1_0_0_2_0 returns Multiplication
	 *     ComparisonOperators.LE_1_0_0_3_0 returns Multiplication
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns Multiplication
	 *     ComparisonOperators.NE_1_0_0_5_0 returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0_0_0_0 returns Multiplication
	 *     Addition.Minus_1_0_0_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0_0_0_0 returns Multiplication
	 *     Multiplication.Divide_1_0_0_1_0 returns Multiplication
	 *     Multiplication.Modulo_1_0_0_2_0 returns Multiplication
	 *     Unary returns Multiplication
	 *     UnaryExpressionNotPlusMinus returns Multiplication
	 *     PrimaryExpression returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0_0_0_0 right=Unary)
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationAccess().getMultiplicationLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationAccess().getRightUnaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotBooleanExpression
	 *     Assign returns NotBooleanExpression
	 *     Assign.Assign_1_0 returns NotBooleanExpression
	 *     OrExpression returns NotBooleanExpression
	 *     OrExpression.OrExpression_1_0 returns NotBooleanExpression
	 *     AndExpression returns NotBooleanExpression
	 *     AndExpression.AndExpression_1_0 returns NotBooleanExpression
	 *     ComparisonOperators returns NotBooleanExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns NotBooleanExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns NotBooleanExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns NotBooleanExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns NotBooleanExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns NotBooleanExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns NotBooleanExpression
	 *     Addition returns NotBooleanExpression
	 *     Addition.Addition_1_0_0_0_0 returns NotBooleanExpression
	 *     Addition.Minus_1_0_0_1_0 returns NotBooleanExpression
	 *     Multiplication returns NotBooleanExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns NotBooleanExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns NotBooleanExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns NotBooleanExpression
	 *     Unary returns NotBooleanExpression
	 *     UnaryExpressionNotPlusMinus returns NotBooleanExpression
	 *     NotBooleanExpression returns NotBooleanExpression
	 *     PrimaryExpression returns NotBooleanExpression
	 *
	 * Constraint:
	 *     exp=Unary
	 */
	protected void sequence_NotBooleanExpression(ISerializationContext context, NotBooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotBooleanExpressionAccess().getExpUnaryParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     Assign returns OrExpression
	 *     Assign.Assign_1_0 returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     ComparisonOperators returns OrExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns OrExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns OrExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns OrExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns OrExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns OrExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns OrExpression
	 *     Addition returns OrExpression
	 *     Addition.Addition_1_0_0_0_0 returns OrExpression
	 *     Addition.Minus_1_0_0_1_0 returns OrExpression
	 *     Multiplication returns OrExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns OrExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns OrExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns OrExpression
	 *     Unary returns OrExpression
	 *     UnaryExpressionNotPlusMinus returns OrExpression
	 *     PrimaryExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 right=AndExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OverrideAction returns OverrideAction
	 *
	 * Constraint:
	 *     (actionName=[Action|ID] expressions+=Expression*)
	 */
	protected void sequence_OverrideAction(ISerializationContext context, OverrideAction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Param returns Param
	 *     Property returns Param
	 *
	 * Constraint:
	 *     (name=ID type=VarType)
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.PROPERTY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.PROPERTY__NAME));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.PARAM__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.PARAM__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParamAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParamAccess().getTypeVarTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Payload returns Payload
	 *
	 * Constraint:
	 *     (params+=Param params+=Param*)
	 */
	protected void sequence_Payload(ISerializationContext context, Payload semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns Port
	 *
	 * Constraint:
	 *     portnumber=INT
	 */
	protected void sequence_Port(ISerializationContext context, Port semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.PORT__PORTNUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.PORT__PORTNUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortAccess().getPortnumberINTTerminalRuleCall_2_0(), semanticObject.getPortnumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     QName returns QName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_QName(ISerializationContext context, QName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.QNAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.QNAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQNameAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Range returns Range
	 *
	 * Constraint:
	 *     (from=Value to=Value)
	 */
	protected void sequence_Range(ISerializationContext context, Range semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.RANGE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.RANGE__FROM));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.RANGE__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.RANGE__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRangeAccess().getFromValueParserRuleCall_1_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getRangeAccess().getToValueParserRuleCall_3_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RealLiteral returns RealLiteral
	 *     Expression returns RealLiteral
	 *     Assign returns RealLiteral
	 *     Assign.Assign_1_0 returns RealLiteral
	 *     OrExpression returns RealLiteral
	 *     OrExpression.OrExpression_1_0 returns RealLiteral
	 *     AndExpression returns RealLiteral
	 *     AndExpression.AndExpression_1_0 returns RealLiteral
	 *     ComparisonOperators returns RealLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns RealLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns RealLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns RealLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns RealLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns RealLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns RealLiteral
	 *     Addition returns RealLiteral
	 *     Addition.Addition_1_0_0_0_0 returns RealLiteral
	 *     Addition.Minus_1_0_0_1_0 returns RealLiteral
	 *     Multiplication returns RealLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns RealLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns RealLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns RealLiteral
	 *     Unary returns RealLiteral
	 *     UnaryExpressionNotPlusMinus returns RealLiteral
	 *     PrimaryExpression returns RealLiteral
	 *     LiteralOrIdentifier returns RealLiteral
	 *     Literal returns RealLiteral
	 *
	 * Constraint:
	 *     (intPart=INT decimalPart=INT)
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.REAL_LITERAL__INT_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.REAL_LITERAL__INT_PART));
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.REAL_LITERAL__DECIMAL_PART) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.REAL_LITERAL__DECIMAL_PART));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getIntPartINTTerminalRuleCall_0_0(), semanticObject.getIntPart());
		feeder.accept(grammarAccess.getRealLiteralAccess().getDecimalPartINTTerminalRuleCall_2_0(), semanticObject.getDecimalPart());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DotExpression returns SingleRef
	 *     DotExpression.DotExpression_1_0 returns SingleRef
	 *     SingleRef returns SingleRef
	 *
	 * Constraint:
	 *     SingleRef=[Property|ID]
	 */
	protected void sequence_SingleRef(ISerializationContext context, SingleRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.SINGLE_REF__SINGLE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.SINGLE_REF__SINGLE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleRefAccess().getSingleRefPropertyIDTerminalRuleCall_1_0_1(), semanticObject.eGet(UnityPackage.Literals.SINGLE_REF__SINGLE_REF, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Specification returns Specification
	 *
	 * Constraint:
	 *     (spec+=UnityObject | spec+=MetaObject | spec+=ENV)+
	 */
	protected void sequence_Specification(ISerializationContext context, Specification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StLiteral
	 *     Assign returns StLiteral
	 *     Assign.Assign_1_0 returns StLiteral
	 *     OrExpression returns StLiteral
	 *     OrExpression.OrExpression_1_0 returns StLiteral
	 *     AndExpression returns StLiteral
	 *     AndExpression.AndExpression_1_0 returns StLiteral
	 *     ComparisonOperators returns StLiteral
	 *     ComparisonOperators.GT_1_0_0_0_0 returns StLiteral
	 *     ComparisonOperators.LT_1_0_0_1_0 returns StLiteral
	 *     ComparisonOperators.GE_1_0_0_2_0 returns StLiteral
	 *     ComparisonOperators.LE_1_0_0_3_0 returns StLiteral
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns StLiteral
	 *     ComparisonOperators.NE_1_0_0_5_0 returns StLiteral
	 *     Addition returns StLiteral
	 *     Addition.Addition_1_0_0_0_0 returns StLiteral
	 *     Addition.Minus_1_0_0_1_0 returns StLiteral
	 *     Multiplication returns StLiteral
	 *     Multiplication.Multiplication_1_0_0_0_0 returns StLiteral
	 *     Multiplication.Divide_1_0_0_1_0 returns StLiteral
	 *     Multiplication.Modulo_1_0_0_2_0 returns StLiteral
	 *     Unary returns StLiteral
	 *     UnaryExpressionNotPlusMinus returns StLiteral
	 *     PrimaryExpression returns StLiteral
	 *     LiteralOrIdentifier returns StLiteral
	 *     Literal returns StLiteral
	 *     StLiteral returns StLiteral
	 *
	 * Constraint:
	 *     string=STRING
	 */
	protected void sequence_StLiteral(ISerializationContext context, StLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.ST_LITERAL__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.ST_LITERAL__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStLiteralAccess().getStringSTRINGTerminalRuleCall_1_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     Assign returns UnaryExpression
	 *     Assign.Assign_1_0 returns UnaryExpression
	 *     OrExpression returns UnaryExpression
	 *     OrExpression.OrExpression_1_0 returns UnaryExpression
	 *     AndExpression returns UnaryExpression
	 *     AndExpression.AndExpression_1_0 returns UnaryExpression
	 *     ComparisonOperators returns UnaryExpression
	 *     ComparisonOperators.GT_1_0_0_0_0 returns UnaryExpression
	 *     ComparisonOperators.LT_1_0_0_1_0 returns UnaryExpression
	 *     ComparisonOperators.GE_1_0_0_2_0 returns UnaryExpression
	 *     ComparisonOperators.LE_1_0_0_3_0 returns UnaryExpression
	 *     ComparisonOperators.EQ_1_0_0_4_0 returns UnaryExpression
	 *     ComparisonOperators.NE_1_0_0_5_0 returns UnaryExpression
	 *     Addition returns UnaryExpression
	 *     Addition.Addition_1_0_0_0_0 returns UnaryExpression
	 *     Addition.Minus_1_0_0_1_0 returns UnaryExpression
	 *     Multiplication returns UnaryExpression
	 *     Multiplication.Multiplication_1_0_0_0_0 returns UnaryExpression
	 *     Multiplication.Divide_1_0_0_1_0 returns UnaryExpression
	 *     Multiplication.Modulo_1_0_0_2_0 returns UnaryExpression
	 *     Unary returns UnaryExpression
	 *     UnaryExpressionNotPlusMinus returns UnaryExpression
	 *     PrimaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     exp=Unary
	 */
	protected void sequence_Unary(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, UnityPackage.Literals.UNARY_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, UnityPackage.Literals.UNARY_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryAccess().getExpUnaryParserRuleCall_1_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnityObject returns UnityObject
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         type=[MetaObject|ID] 
	 *         (configurations+=ConfigAssignment | newActions+=Action | overrideActions+=OverrideAction | properties+=Attribute)*
	 *     )
	 */
	protected void sequence_UnityObject(ISerializationContext context, UnityObject semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Value returns Value
	 *
	 * Constraint:
	 *     ((minues?='-'? value=INT) | fixedPointValue=RealLiteral)
	 */
	protected void sequence_Value(ISerializationContext context, Value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarType returns VarType
	 *
	 * Constraint:
	 *     (name='bool' | name='int' | name='string' | name='real')
	 */
	protected void sequence_VarType(ISerializationContext context, VarType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfaceType returns interfaceType
	 *
	 * Constraint:
	 *     (name='TCP' | name='IPC')
	 */
	protected void sequence_interfaceType(ISerializationContext context, interfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
