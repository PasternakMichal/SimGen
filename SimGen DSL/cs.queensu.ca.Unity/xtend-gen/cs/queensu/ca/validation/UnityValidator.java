/**
 * generated by Xtext 2.10.0
 */
package cs.queensu.ca.validation;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import cs.queensu.ca.typing.BoolType;
import cs.queensu.ca.typing.DivideByZero;
import cs.queensu.ca.typing.ExpressionsType;
import cs.queensu.ca.typing.NotValid;
import cs.queensu.ca.unity.Addition;
import cs.queensu.ca.unity.AndExpression;
import cs.queensu.ca.unity.Assign;
import cs.queensu.ca.unity.Attribute;
import cs.queensu.ca.unity.Config;
import cs.queensu.ca.unity.Divide;
import cs.queensu.ca.unity.EQ;
import cs.queensu.ca.unity.Expression;
import cs.queensu.ca.unity.GE;
import cs.queensu.ca.unity.GT;
import cs.queensu.ca.unity.Identifier;
import cs.queensu.ca.unity.LE;
import cs.queensu.ca.unity.LT;
import cs.queensu.ca.unity.Minus;
import cs.queensu.ca.unity.Modulo;
import cs.queensu.ca.unity.Multiplication;
import cs.queensu.ca.unity.NE;
import cs.queensu.ca.unity.NotBooleanExpression;
import cs.queensu.ca.unity.OrExpression;
import cs.queensu.ca.unity.UnaryExpression;
import cs.queensu.ca.unity.UnityPackage;
import cs.queensu.ca.validation.AbstractUnityValidator;
import cs.queensu.ca.validation.UnityTypeValidationUtility;
import org.apache.log4j.Logger;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class UnityValidator extends AbstractUnityValidator {
  public final static String INVALID_NAME = "invalidName";
  
  public final static String WRONG_TYPE = "cs.queensu.ca.Unity.Expression.WrongType";
  
  public final static String divide_BY_Zero = "cs.queensu.ca.Unity.Expression.DivideBYZero";
  
  public final static String Wrong_Expression_Usage = "cs.queensu.ca.Unity.WrongExpressionUsage";
  
  private final static Logger LOGGER = Logger.getLogger(UnityValidator.class.getName());
  
  @Inject
  @Extension
  private UnityTypeValidationUtility _unityTypeValidationUtility;
  
  private final BoolType boolType = UnityTypeValidationUtility.boolType;
  
  private final DivideByZero divideByZero = UnityTypeValidationUtility.divideByZero;
  
  private final NotValid notValid = UnityTypeValidationUtility.notValid;
  
  @Check
  public void checkExpectedType(final GT g) {
    if (((g.getLeft() != null) && (g.getRest() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(g);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _rest = g.getRest();
        ExpressionsType _typeFor_1 = null;
        if (_rest!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_rest);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = g.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not apply GT to" + _string);
          String _plus_1 = (_plus + " and ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.GT__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not apply GT to" + _string_2);
            String _plus_4 = (_plus_3 + " and ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.GT__REST, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final LT l) {
    if (((l.getLeft() != null) && (l.getRest() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(l);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _rest = l.getRest();
        ExpressionsType _typeFor_1 = null;
        if (_rest!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_rest);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = l.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not apply LT to " + _string);
          String _plus_1 = (_plus + " and ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.LT__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not apply LT to " + _string_2);
            String _plus_4 = (_plus_3 + " and ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.LT__REST, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final GE ge) {
    if (((ge.getLeft() != null) && (ge.getRest() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(ge);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _rest = ge.getRest();
        ExpressionsType _typeFor_1 = null;
        if (_rest!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_rest);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = ge.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not apply GE to" + _string);
          String _plus_1 = (_plus + " and ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.GE__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not apply GE to" + _string_2);
            String _plus_4 = (_plus_3 + " and ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.GE__REST, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final LE le) {
    if (((le.getLeft() != null) && (le.getRest() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(le);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _rest = le.getRest();
        ExpressionsType _typeFor_1 = null;
        if (_rest!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_rest);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = le.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not apply LE to" + _string);
          String _plus_1 = (_plus + " and ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.LE__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not apply LE to" + _string_2);
            String _plus_4 = (_plus_3 + " and ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.LE__REST, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final EQ e) {
    if (((e.getLeft() != null) && (e.getRest() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(e);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _rest = e.getRest();
        ExpressionsType _typeFor_1 = null;
        if (_rest!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_rest);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = e.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not apply EQ" + _string);
          String _plus_1 = (_plus + " to ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.EQ__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.boolType));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not apply EQ" + _string_2);
            String _plus_4 = (_plus_3 + " with ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.EQ__REST, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final NE n) {
    if (((n.getLeft() != null) && (n.getRest() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(n);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _rest = n.getRest();
        ExpressionsType _typeFor_1 = null;
        if (_rest!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_rest);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = n.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not apply NE to" + _string);
          String _plus_1 = (_plus + " and ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.NE__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not apply NE to" + _string_2);
            String _plus_4 = (_plus_3 + " and ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.NE__REST, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final NotBooleanExpression nb) {
    Expression _exp = nb.getExp();
    boolean _tripleNotEquals = (_exp != null);
    if (_tripleNotEquals) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(nb);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _exp_1 = nb.getExp();
        ExpressionsType _typeFor_1 = null;
        if (_exp_1!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_exp_1);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object expressionType = _elvis;
        String _string = null;
        if (expressionType!=null) {
          _string=expressionType.toString();
        }
        String _plus = ("Can not apply NotBooleanExpression to " + _string);
        this.error(_plus, 
          UnityPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP, UnityValidator.WRONG_TYPE);
      }
    }
  }
  
  @Check
  public void checkExpectedType(final OrExpression or) {
    if (((or.getLeft() != null) && (or.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(or);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _right = or.getRight();
        ExpressionsType _typeFor_1 = null;
        if (_right!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_right);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = or.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not or " + _string);
          String _plus_1 = (_plus + " with ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.OR_EXPRESSION__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not or " + _string_2);
            String _plus_4 = (_plus_3 + " with ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.OR_EXPRESSION__RIGHT, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final AndExpression and) {
    if (((and.getLeft() != null) && (and.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(and);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _right = and.getRight();
        ExpressionsType _typeFor_1 = null;
        if (_right!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_right);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = and.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        boolean _notEquals = (!Objects.equal(rightType, this.notValid));
        if (_notEquals) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not and " + _string);
          String _plus_1 = (_plus + " with ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.AND_EXPRESSION__LEFT, UnityValidator.WRONG_TYPE);
        } else {
          boolean _notEquals_1 = (!Objects.equal(leftType, this.notValid));
          if (_notEquals_1) {
            String _string_2 = null;
            if (leftType!=null) {
              _string_2=leftType.toString();
            }
            String _plus_3 = ("Can not and " + _string_2);
            String _plus_4 = (_plus_3 + " with ");
            String _string_3 = null;
            if (rightType!=null) {
              _string_3=rightType.toString();
            }
            String _plus_5 = (_plus_4 + _string_3);
            this.error(_plus_5, 
              UnityPackage.Literals.AND_EXPRESSION__RIGHT, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final UnaryExpression u) {
    Expression _exp = u.getExp();
    boolean _tripleNotEquals = (_exp != null);
    if (_tripleNotEquals) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(u);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _exp_1 = u.getExp();
        ExpressionsType _typeFor_1 = null;
        if (_exp_1!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_exp_1);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object expressionType = _elvis;
        String _string = null;
        if (expressionType!=null) {
          _string=expressionType.toString();
        }
        String _plus = ("Can not apply UnaryExpression to " + _string);
        this.error(_plus, 
          UnityPackage.Literals.UNARY_EXPRESSION__EXP, UnityValidator.WRONG_TYPE);
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Addition a) {
    if (((a.getLeft() != null) && (a.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(a);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _right = a.getRight();
        ExpressionsType _typeFor_1 = null;
        if (_right!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_right);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = a.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not add " + _string);
          String _plus_1 = (_plus + " with ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.ADDITION__LEFT, UnityValidator.WRONG_TYPE);
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Identifier i) {
    ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(i);
    boolean _equals = Objects.equal(_typeFor, this.notValid);
    if (_equals) {
      this.error("Invalid type", UnityPackage.Literals.IDENTIFIER__REFRENCE, UnityValidator.WRONG_TYPE);
    }
  }
  
  @Check
  public void checkExpectedType(final Assign a) {
    if (((a.getLeft() != null) && (a.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(a);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _right = a.getRight();
        ExpressionsType _typeFor_1 = null;
        if (_right!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_right);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = a.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
          String _string = rightType.toString();
          String _plus = ("Can not assign " + _string);
          String _plus_1 = (_plus + " to ");
          String _string_1 = leftType.toString();
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.ASSIGN__RIGHT, UnityValidator.WRONG_TYPE);
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Config ca) {
    boolean _and = false;
    Attribute _propertyName = null;
    if (ca!=null) {
      _propertyName=ca.getPropertyName();
    }
    boolean _tripleNotEquals = (_propertyName != null);
    if (!_tripleNotEquals) {
      _and = false;
    } else {
      Expression _propertyValue = null;
      if (ca!=null) {
        _propertyValue=ca.getPropertyValue();
      }
      boolean _tripleNotEquals_1 = (_propertyValue != null);
      _and = _tripleNotEquals_1;
    }
    if (_and) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(ca);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _propertyValue_1 = null;
        if (ca!=null) {
          _propertyValue_1=ca.getPropertyValue();
        }
        ExpressionsType _typeFor_1 = null;
        if (_propertyValue_1!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_propertyValue_1);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Attribute _propertyName_1 = null;
        if (ca!=null) {
          _propertyName_1=ca.getPropertyName();
        }
        ExpressionsType _typeFor_2 = null;
        if (_propertyName_1!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_propertyName_1);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
          String _string = rightType.toString();
          String _plus = ("Can not assign " + _string);
          String _plus_1 = (_plus + " to ");
          String _string_1 = leftType.toString();
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.CONFIG__PROPERTY_NAME, UnityValidator.WRONG_TYPE);
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Minus m) {
    if (((m.getLeft() != null) && (m.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(m);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _right = m.getRight();
        ExpressionsType _typeFor_1 = null;
        if (_right!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_right);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = m.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
          String _string = rightType.toString();
          String _plus = ("Can not deduct " + _string);
          String _plus_1 = (_plus + " from ");
          String _string_1 = leftType.toString();
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.MINUS__RIGHT, UnityValidator.WRONG_TYPE);
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Multiplication mp) {
    if (((mp.getLeft() != null) && (mp.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(mp);
      boolean _equals = Objects.equal(_typeFor, this.notValid);
      boolean _not = (!_equals);
      if (_not) {
        return;
      } else {
        Object _elvis = null;
        Expression _right = mp.getRight();
        ExpressionsType _typeFor_1 = null;
        if (_right!=null) {
          _typeFor_1=this._unityTypeValidationUtility.typeFor(_right);
        }
        if (_typeFor_1 != null) {
          _elvis = _typeFor_1;
        } else {
          _elvis = "NUll";
        }
        final Object rightType = _elvis;
        Object _elvis_1 = null;
        Expression _left = mp.getLeft();
        ExpressionsType _typeFor_2 = null;
        if (_left!=null) {
          _typeFor_2=this._unityTypeValidationUtility.typeFor(_left);
        }
        if (_typeFor_2 != null) {
          _elvis_1 = _typeFor_2;
        } else {
          _elvis_1 = "NUll";
        }
        final Object leftType = _elvis_1;
        if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
          String _string = null;
          if (leftType!=null) {
            _string=leftType.toString();
          }
          String _plus = ("Can not multiply " + _string);
          String _plus_1 = (_plus + " with ");
          String _string_1 = null;
          if (rightType!=null) {
            _string_1=rightType.toString();
          }
          String _plus_2 = (_plus_1 + _string_1);
          this.error(_plus_2, 
            UnityPackage.Literals.MULTIPLICATION__RIGHT, UnityValidator.WRONG_TYPE);
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Divide d) {
    if (((d.getLeft() != null) && (d.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(d);
      boolean _equals = Objects.equal(_typeFor, this.divideByZero);
      if (_equals) {
        this.error("Divide  By Zero", UnityPackage.Literals.DIVIDE__RIGHT, UnityValidator.WRONG_TYPE);
      } else {
        ExpressionsType _typeFor_1 = this._unityTypeValidationUtility.typeFor(d);
        boolean _equals_1 = Objects.equal(_typeFor_1, this.notValid);
        boolean _not = (!_equals_1);
        if (_not) {
          return;
        } else {
          Object _elvis = null;
          Expression _right = d.getRight();
          ExpressionsType _typeFor_2 = null;
          if (_right!=null) {
            _typeFor_2=this._unityTypeValidationUtility.typeFor(_right);
          }
          if (_typeFor_2 != null) {
            _elvis = _typeFor_2;
          } else {
            _elvis = "NUll";
          }
          final Object rightType = _elvis;
          Object _elvis_1 = null;
          Expression _left = d.getLeft();
          ExpressionsType _typeFor_3 = null;
          if (_left!=null) {
            _typeFor_3=this._unityTypeValidationUtility.typeFor(_left);
          }
          if (_typeFor_3 != null) {
            _elvis_1 = _typeFor_3;
          } else {
            _elvis_1 = "NUll";
          }
          final Object leftType = _elvis_1;
          if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
            String _string = null;
            if (leftType!=null) {
              _string=leftType.toString();
            }
            String _plus = ("Can not divide " + _string);
            String _plus_1 = (_plus + " by ");
            String _string_1 = null;
            if (rightType!=null) {
              _string_1=rightType.toString();
            }
            String _plus_2 = (_plus_1 + _string_1);
            this.error(_plus_2, 
              UnityPackage.Literals.DIVIDE__RIGHT, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkExpectedType(final Modulo mo) {
    if (((mo.getLeft() != null) && (mo.getRight() != null))) {
      ExpressionsType _typeFor = this._unityTypeValidationUtility.typeFor(mo);
      boolean _equals = Objects.equal(_typeFor, this.divideByZero);
      if (_equals) {
        this.error("Divide  By Zero", UnityPackage.Literals.MODULO__RIGHT, UnityValidator.WRONG_TYPE);
      } else {
        ExpressionsType _typeFor_1 = this._unityTypeValidationUtility.typeFor(mo);
        boolean _equals_1 = Objects.equal(_typeFor_1, this.notValid);
        boolean _not = (!_equals_1);
        if (_not) {
          return;
        } else {
          Object _elvis = null;
          Expression _right = mo.getRight();
          ExpressionsType _typeFor_2 = null;
          if (_right!=null) {
            _typeFor_2=this._unityTypeValidationUtility.typeFor(_right);
          }
          if (_typeFor_2 != null) {
            _elvis = _typeFor_2;
          } else {
            _elvis = "NUll";
          }
          final Object rightType = _elvis;
          Object _elvis_1 = null;
          Expression _left = mo.getLeft();
          ExpressionsType _typeFor_3 = null;
          if (_left!=null) {
            _typeFor_3=this._unityTypeValidationUtility.typeFor(_left);
          }
          if (_typeFor_3 != null) {
            _elvis_1 = _typeFor_3;
          } else {
            _elvis_1 = "NUll";
          }
          final Object leftType = _elvis_1;
          if (((!Objects.equal(rightType, this.notValid)) && (!Objects.equal(leftType, this.notValid)))) {
            String _string = null;
            if (leftType!=null) {
              _string=leftType.toString();
            }
            String _plus = ("Can not module " + _string);
            String _plus_1 = (_plus + " by ");
            String _string_1 = null;
            if (rightType!=null) {
              _string_1=rightType.toString();
            }
            String _plus_2 = (_plus_1 + _string_1);
            this.error(_plus_2, 
              UnityPackage.Literals.MODULO__RIGHT, UnityValidator.WRONG_TYPE);
          }
        }
      }
    }
  }
}
