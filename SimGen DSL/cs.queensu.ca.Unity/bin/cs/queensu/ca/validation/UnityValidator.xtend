/*
 * generated by Xtext 2.10.0
 */
package cs.queensu.ca.validation

import com.google.inject.Inject
import org.eclipse.xtext.validation.Check
import org.apache.log4j.Logger
import cs.queensu.ca.unity.UnityPackage
import cs.queensu.ca.unity.GT
import cs.queensu.ca.unity.LT
import cs.queensu.ca.unity.GE
import cs.queensu.ca.unity.LE
import cs.queensu.ca.unity.EQ
import cs.queensu.ca.unity.NE
import cs.queensu.ca.unity.NotBooleanExpression
import cs.queensu.ca.unity.OrExpression
import cs.queensu.ca.unity.AndExpression
import cs.queensu.ca.unity.UnaryExpression
import cs.queensu.ca.unity.Addition
import cs.queensu.ca.unity.Identifier
import cs.queensu.ca.unity.Assign
import cs.queensu.ca.unity.Minus
import cs.queensu.ca.unity.Multiplication
import cs.queensu.ca.unity.Modulo
import cs.queensu.ca.unity.Divide
import cs.queensu.ca.unity.ConfigAssignment
import cs.queensu.ca.unity.Config
import cs.queensu.ca.unity.Attribute

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
 

 
class UnityValidator extends AbstractUnityValidator {
	
	public static val INVALID_NAME = 'invalidName'
	public static val WRONG_TYPE ="cs.queensu.ca.Unity.Expression.WrongType"
	public static val divide_BY_Zero ="cs.queensu.ca.Unity.Expression.DivideBYZero"
	public static val Wrong_Expression_Usage ="cs.queensu.ca.Unity.WrongExpressionUsage"
	private static final Logger LOGGER = Logger.getLogger(UnityValidator.getName() );
	
	@Inject extension UnityTypeValidationUtility 
	private val boolType=UnityTypeValidationUtility::boolType
	private val divideByZero=UnityTypeValidationUtility::divideByZero
	private val notValid=UnityTypeValidationUtility::notValid
		
	@Check
	def checkExpectedType(GT g) {
		if (g.left!==null && g.rest!==null){
			if (!(g.typeFor==notValid))
				return // GT is valid
			else {
				val rightType=g.rest?.typeFor ?: 'NUll' 
				val leftType=g.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not apply GT to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.GT__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not apply GT to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.GT__REST, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(LT l) {
		if (l.left!==null && l.rest!==null){
			if (!(l.typeFor==notValid))
				return // LT is valid
			else {
				val rightType=l.rest?.typeFor ?: 'NUll' 
				val leftType=l.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not apply LT to "+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.LT__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not apply LT to "+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.LT__REST, WRONG_TYPE)
				}
			}
		}
	}
	
	@Check
	def checkExpectedType(GE ge) {
		if (ge.left!==null && ge.rest!==null){
			if (!(ge.typeFor==notValid))
				return // GE is valid
			else {
				val rightType=ge.rest?.typeFor ?: 'NUll' 
				val leftType=ge.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not apply GE to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.GE__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not apply GE to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.GE__REST, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(LE le) {
		if (le.left!==null && le.rest!==null){
			if (!(le.typeFor==notValid))
				return // LE is valid
			else {
				val rightType=le.rest?.typeFor ?: 'NUll' 
				val leftType=le.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not apply LE to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.LE__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not apply LE to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.LE__REST, WRONG_TYPE)
				}
			}
		}
	
	}
	
	@Check
	def checkExpectedType(EQ e) {
		if (e.left!==null && e.rest!==null){
			if (!(e.typeFor==notValid))
				return // EQ is valid
			else {
				val rightType=e.rest?.typeFor ?: 'NUll' 
				val leftType=e.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not apply EQ"+ leftType?.toString +" to "+ rightType?.toString,
					UnityPackage.Literals.EQ__LEFT, WRONG_TYPE)
				}
				else if (leftType!=boolType){
					error("Can not apply EQ"+ leftType?.toString +" with "+ rightType?.toString,
					UnityPackage.Literals.EQ__REST, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(NE n) {
		if (n.left!==null && n.rest!==null){
			if (!(n.typeFor==notValid))
				return // NE is valid
			else {
				val rightType=n.rest?.typeFor ?: 'NUll' 
				val leftType=n.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not apply NE to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.NE__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not apply NE to"+ leftType?.toString +" and "+ rightType?.toString,
					UnityPackage.Literals.NE__REST, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(NotBooleanExpression nb) {
		if (nb.exp!==null){
			if (!(nb.typeFor==notValid))
				return // NotBoolean is valid
			else {
				val expressionType=nb.exp?.typeFor ?: 'NUll' 
				error("Can not apply NotBooleanExpression to "+ expressionType?.toString,
				UnityPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP, WRONG_TYPE)
			}
		}
	}
	@Check
	def checkExpectedType(OrExpression or) {
		if (or.left!==null && or.right!==null){
			if (!(or.typeFor==notValid))
				return // or is valid
			else {
				val rightType=or.right?.typeFor ?: 'NUll' 
				val leftType=or.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not or "+ leftType?.toString +" with "+ rightType?.toString,
					UnityPackage.Literals.OR_EXPRESSION__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not or "+ leftType?.toString +" with "+ rightType?.toString,
					UnityPackage.Literals.OR_EXPRESSION__RIGHT, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(AndExpression and) {
		if (and.left!==null && and.right!==null){
			if (!(and.typeFor==notValid))
				return // and is valid
			else {
				val rightType=and.right?.typeFor ?: 'NUll' 
				val leftType=and.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid){
					error("Can not and "+ leftType?.toString +" with "+ rightType?.toString,
					UnityPackage.Literals.AND_EXPRESSION__LEFT, WRONG_TYPE)
				}
				else if (leftType!=notValid){
					error("Can not and "+ leftType?.toString +" with "+ rightType?.toString,
					UnityPackage.Literals.AND_EXPRESSION__RIGHT, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(UnaryExpression u) {
		if (u.exp!==null){
			if (!(u.typeFor==notValid))
				return // UnaryExpression is valid
			else {
				val expressionType=u.exp?.typeFor ?: 'NUll' 
				error("Can not apply UnaryExpression to "+ expressionType?.toString,
				UnityPackage.Literals.UNARY_EXPRESSION__EXP, WRONG_TYPE)
			}
		}
	}	

	@Check
	def checkExpectedType(Addition a) {
		if (a.left!==null && a.right!==null ){
				if (!(a.typeFor==notValid))
					return // addition is valid
				else {
					val rightType=a.right?.typeFor ?: 'NUll' 
					val leftType=a.left?.typeFor  ?: 'NUll' 
					if (rightType!=notValid  && leftType!=notValid){
						error("Can not add "+ leftType?.toString +" with "+ rightType?.toString,
						UnityPackage.Literals.ADDITION__LEFT, WRONG_TYPE)
					}
				}
		}
	}

	@Check
	def checkExpectedType(Identifier i) {
		if (typeFor(i)==notValid){
			error("Invalid type", UnityPackage.Literals.IDENTIFIER__REFRENCE, WRONG_TYPE)
		}

	}
	@Check
	def checkExpectedType(Assign a) {
		if (a.left!==null && a.right!==null ){
			if (!(a.typeFor==notValid))
				return // Assign is valid
			else {
				val rightType=a.right?.typeFor ?: 'NUll' 
				val leftType=a.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid  && leftType!=notValid){
					error("Can not assign "+ rightType.toString+" to "+ leftType.toString,
					UnityPackage.Literals.ASSIGN__RIGHT, WRONG_TYPE)
				}
			}	
		}
	}
	@Check
	def checkExpectedType(Config ca) {
		
		//var Config config=ca.configs as Config
		if ((ca?.propertyName!==null) && (ca?.propertyValue!==null)){
			if (!(ca.typeFor==notValid))
				return // Config is valid
			else {
				val rightType=ca?.propertyValue?.typeFor ?: 'NUll' 
				val leftType=ca?.propertyName?.typeFor  ?: 'NUll' 
				if (rightType!=notValid  && leftType!=notValid){
					error("Can not assign "+ rightType.toString+" to "+ leftType.toString,
					UnityPackage.Literals.CONFIG__PROPERTY_NAME, WRONG_TYPE)
				}
			}	
		}
	}
	@Check
	def checkExpectedType(Minus m) {
		if (m.left!==null && m.right!==null ){
			if (!(m.typeFor==notValid))
				return // Minus is valid
			else {
				val rightType=m.right?.typeFor ?: 'NUll' 
				val leftType=m.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid  && leftType!=notValid){
					error("Can not deduct "+ rightType.toString +" from "+ leftType.toString,
					UnityPackage.Literals.MINUS__RIGHT, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(Multiplication mp){
		if (mp.left!==null && mp.right!==null ){
			if (!(mp.typeFor==notValid))
				return // Multiplication is valid
			else {
				val rightType=mp.right?.typeFor ?: 'NUll' 
				val leftType=mp.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid  && leftType!=notValid){
					error("Can not multiply "+ leftType?.toString +" with "+ rightType?.toString,
					UnityPackage.Literals.MULTIPLICATION__RIGHT, WRONG_TYPE)
				}
			}
		}
	}
	
	@Check
	def checkExpectedType(Divide d){
		if (d.left!==null && d.right!==null ){
		    if (d.typeFor==divideByZero)
					error("Divide  By Zero",UnityPackage.Literals.DIVIDE__RIGHT, WRONG_TYPE)
			else if (!(d.typeFor==notValid))
				return // Divide is valid	
			else {
				val rightType=d.right?.typeFor ?: 'NUll' 
				val leftType=d.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid  && leftType!=notValid){
					error("Can not divide "+ leftType?.toString +" by "+ rightType?.toString,
					UnityPackage.Literals.DIVIDE__RIGHT, WRONG_TYPE)
				}
			}
		}
	}
	@Check
	def checkExpectedType(Modulo mo){
		if (mo.left!==null && mo.right!==null ){
		    if (mo.typeFor==divideByZero)
					error("Divide  By Zero",UnityPackage.Literals.MODULO__RIGHT, WRONG_TYPE)
			else if (!(mo.typeFor==notValid))
				return // Modulo is valid	
			else {
				val rightType=mo.right?.typeFor ?: 'NUll' 
				val leftType=mo.left?.typeFor  ?: 'NUll' 
				if (rightType!=notValid  && leftType!=notValid){
					error("Can not module "+ leftType?.toString +" by "+ rightType?.toString,
					UnityPackage.Literals.MODULO__RIGHT, WRONG_TYPE)
				
				}
			
			}
		}
	}
}